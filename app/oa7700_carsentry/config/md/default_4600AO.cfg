# New Input File Format is as follows
# <ParameterName> = <ParameterValue> # Comment
#
# See cfg_input.h for a list of supported ParameterNames


##########################################################################################
# Input and output files
##########################################################################################
InputFileType       = 1              # 0: YUV420P video, 1: auto detect, 2: Y video, 3: YUV422P video
InputFilePath       = "../../../data/bcap20200804_170213_640x360_P420.yuv"     # 
InputWidth          = 0            # input video/image width, ignore if InputFileType is 1
InputHeight         = 0            # input video/image height, ignore if InputFileType is 1
StartFrameIdx       = 0 #1280   #0          # start frame index. Start from 0.
FramesToBeProcessed = -1 #100 # 400 #-1 #20            # number of frames to be processed. -1: all frames after StartFrameIdx.
OutputFilePath      = "output"     # output files path



##########################################################################################
# parameters
##########################################################################################
MD_Scale_Method          =  0        # 0: scale down using ffmpeg. (Not bit-match with HW scale !). 1. use MD HW scale(downsample actually).
MD_Scale_KeepAspectRatio = 1         # 0: not keep aspect ratio. 1: keep aspect ratio, ScaledH = (nFrmH * MD_ScaledW / nFrmW) & (~1).
MD_ScaledW              = 480 #        # scaled width
MD_ScaledH              = 384 #        # available when (MD_Scale_KeepAspectRatio==0).

MD_Padding_Method  = 0               # about how to get the (MD_HogBlockSize+4)*(MD_HogBlockSize+4) window for each block,
                                     # 0: load a (MD_HogBlockSize+4)*(MD_HogBlockSize+4) window from the image, do padding if it's out of image boundary.
                                     # 1: load a MD_HogBlockSize*MD_HogBlockSize window from the image, pad its surrounding 2 rows/columns with zero.
                                     # 2: HW use this method ;load a MD_HogBlockSize*MD_HogBlockSize window from the image, pad its surrounding 2 rows/columns with its boundary data.

MD_RefFrmIdx        = 1              # 10 #        # suppose current frame index is N, use the (N - MD_RefFrmIdx)th frame as reference frame.



##-------------------------------------------------------------------------------------------------------------------
## Parameters for metrics
##-------------------------------------------------------------------------------------------------------------------
MD_MetricMode       = 3              # 4 bits, [1, 15]
                                     # Specify which metrics to use for motion detection
                                     # bit 0: HOG (same as before)
                                     # bit 1: L1 moment of gradients (both block and cells)    
                                     # bit 2: Center coordinate of gradients (both block and cells)
                                     # bit 3: L1 moments of gradients for each 2x2 block, used to produce high res MD map (320x180/160x90)
                                     # NOTE: 
                                     #      - Ok to enable ANY combination of bit 0/1/2
                                     #      - When bit 3 is on, at least one of 0/1/2 must be turned on
                                     #      - For example, "= 3" would enable both HOG and L1 moment, "=7" would enable all thress metrics,
                                     #                     "= 9" would enable HOG at 320x180 or 160/90 output resolution.
                                     #      - If multiple metrics are enabled, distortion will be calculated as a sum of all enabled metrics
MD_ShiftHistMag2    = 3              # 3 bits, [0, 7]
                                     # shit to be applied to magniture of metric2
MD_ShiftMetric2_Th  = 6              # 4 bits, [0, 15]
                                     # shift value to be applied to metric=2 for adjustment. (night ==> 6, day ==> 7)


##-------------------------------------------------------------------------------------------------------------------
## Parameters for neighbor correlation
##-------------------------------------------------------------------------------------------------------------------
MD_NeighborCorrelation = 1           # 1 bit, [0, 1]
                                     # Looks at temporal/spatial neighbor blocks to trigger motion, def = 0
MD_ActBlk_MinMaxRatio_Scale = 16     # 8 bits, [0, 255]
                                     # Ratio between min and max block dist on previous frames. Used to distinguash a true and false events.
MD_ActBlkRepeatFrmCntTh = 3          # 4 bits, [0, 15]
                                     # minimum # of successive frame count for a block to trigger motion, def = 3
MD_ActNeighborBlkCntTh   = 2         # 4 bits, [0, 9]
                                     # minimum # of neighbour active blocks in a given region to trigger motion, def = 2. Note both processed spatial and temporal neighbors are included.
MD_HogDist_Th_nnAdj_Scale = 4        # 5 bits, [0, 31]
                                     # adjustment factor to "MD_HogDist_Th" based on neighbor availability, def = 4

##-------------------------------------------------------------------------------------------------------------------
## Parameters for handling Luminance change/AGC
##-------------------------------------------------------------------------------------------------------------------
## HW: 0x120 [31:24]. used for neighbor correlation
MD_HogDist_Th_AvgYDiffAdj_Scale = 42 # 8bit [0, 255]
                                     # 0 - no effects, 42 - recommended: a scale factor for adjusting "MD_HogDist_Th" in the presence of global luminance change

##-------------------------------------------------------------------------------------------------------------------
## Parameters for handling rapid MD response
##-------------------------------------------------------------------------------------------------------------------
MD_LowDelayEn                = 1         # 1 bit [0, 1]
                                         # switch to enable low delay MD response, def = 1 
MD_HogDist_Th_lowDelay_shift = 1         # 2 bit [0, 3]
                                         # adjustment factor to "nMD_HogDist_Th" for allowing rapid MD response, def = 1
MD_HogDist_Th_lowDelay_nn_count = 1      # 4 bit [0, 15]
                                         # of nn required for allowing rapid MD response, def = 1
MD_HogDist_Th_LowDelay_prev_nn_count = 1 # 3 bit [0, 7]
                                         # of nn on previous frame required for allowing rapid MD response, def = 1
##-------------------------------------------------------------------------------------------------------------------
##-------------------------------------------------------------------------------------------------------------------
##-------------------------------------------------------------------------------------------------------------------



MD_HogMethod        = 1              # 1: normal HOG
MD_HogDistAvailCheck = 1             # 0: no check, hog distance is available for all blocks. 1: hog distance is available when a block's difference from the reference frame is high.

#parameters useable for (MD_HogMethod==1)
MD_HogBlockSize     = 16             # block size, can't change.
MD_HogCellSize      = 16              # HW:0x00,bit[7];cell size.(support 8 and 16 two cases)
MD_HogBlockStride   = 8              # block stride.can't change.
MD_HogGradX         = "-1,-2,0,2,1"  # a 5x1 template for GradX calculation. (support changed, no longer than 1*5).
MD_HogGradY         = "-1,-2,0,2,1"  # a 1x5 template for GradY calculation. (support changed, no longer than 1*5).
MD_HogMagnitudeWeightEn = 1          # HW:0x00,bit[2]; 1: use weighted gradient magnitude, 0: no weighted gradient magnitude.
MD_HogSmoothBinsEn    = 1            # HW:0x00,bit[1]; 1: apply smooth filter [1/4, 2/4, 1/4] to the histogram bins before normalization. 0: no smooth filter needed.
MD_HogNormalizeMode = 0              # HW:0x00,bit[5:4]; 0: disable hog normalization, 1: enable hog normalization, output hist norm, 2:  enable hog normalization, output sum of gradient magnitude.
MD_HogDist_AvgYDiffCalc_Method = 1   # update threshold, HW uses default method '1'.   0: every block line, 1: every block, 2: every frame.
MD_HogDist_AvgYDiffThre_Scale = 32   # HW:0x18,bit[15:8]; a scale factor with 4 bits precision. AvgYDiffThre = (AvgYDiff * MD_AvgYDiffThre_Scale) >> 4. The bigger of this scale, the higher of the AvgYDiffThre, which will remove more candidate block
MD_HogDist_WeightMethod = 0          # HW:0x00,bit[3]; x2 distance with weighting method. 0: "curBlkVar + abs(curBlkVar - refBlkVar), 1: "curBlkVar + MAX(curBlkVar-refBlkVar, 0). Available when (MD_HogNormalizeMode=1/2).

#Paramerters used for all MD_HogMethod
MD_HogDist_Scale = 20                # HW:0x18,bit[7:0]; a scale factor with 4 bits precision. (HogDist = HogDistOrig * MD_HogDist_Scale) >> 4.
                                     #This is just HogDist stretch ratio. eg: mapping all the HogDist value from 'HogDist' to '4*HogDist', if the stretched value is bigger than 255, it will be set to max value '255'. So set this scale at property value. 
				     #For example, if most of the output block HogDist value is 255, which means this scale value is too large to distinguish the HogDist of each block. 

MD_HogDist_Scale2 = 10               # 8 bits, [0, 255], Counterpart of "MD_HogDist_Scale" for metric=2.   Recommended: 10 --> 640x360,  15 --> 320x180  

MD_DbgEn            = 0xfffa
											# bit 0: output MDet (hog and hog distance calculation) debug information,
                                            # bit1: dump compYUV (comp_*_P420.yuv), 
											# bit2: dump block level hogDist, 
											# bit3: show motion area in input yuv (motionArea_*_P420.yuv),
											# bit4: show hogDist in yuv file (hogDist_*_P420.yuv, the third part of comp_*_P420.yuv).
											# bit5: dump cur and ref frame hog feature output by txt.
											# bit6: dump hog dist feature output by txt.
											# bit7: 0: close SAD. 1: enable SAD
											# bit8: dump effective block hogDist information. The threshold of 'Effective' is control by parmeter 'MD_HogDist_Th'
											# bit9: dump bbox output.
											# bit10: dump Accum output.
MD_PostProcMethod   = 0  #0:Fastest and stable, Single MD post-processing, it use (distMask: 76000-AccumMask, other chips-distMask)
                         #1:Fast and not stable, better than 0. Mulitple object MD post-processing, it can capture multiple motion area, and output motion region with biggest avghog
                         #2:frame correlation method. Need huge memory to calculation correlation features, and HOG feature maps, not suggested on 7600
                         #3:recursive method to calculate bbox
MD_HogDist_Th     = 30   #in 8100MD, for pp method 0 and 4, suggest to set higher than 20; for other methods: suggest to set 15~30
MD_BlkCnt_Th      = 8    #in md PP V2 method0, used to filter out small motion area by block count.
MD_Bbox_PP_Enable   = 0   #update the bbox after BBox generator function, added in 8100 MD

#Paramerters used for MD_Bbox_PP_Enable=1
MD_Bbox_PP_Window = 2              #Bbox correlation window size
MD_PP_Area_Converge_Thresh = 5   #Bbox area convergence threshold
MD_PP_Aspect_Converge_Thresh = 5 #Bbox aspect convergence threshold
											
MD_Sensitivity_Th = 100  #range [0:100], the bigger the higher detection rate.
Obj_Density1_Th = 0.0 #0.0006 #set '0' to close this feature. The threshold of bbox density value(based on effective hog points size), the bigger the less output; If it's night mode: suggested parameters is Obj_Density1_Th=0; 
Obj_Density2_Th = 0.0 #0.0080 #set '0' to close this feature. The threshold of bbox density value(based on effective hog area), the bigger the less output; If it's night mode: suggested parameters is Obj_Density2_Th=0.2;

#next 3 parameters use for temporal feature
MD_HogDist_ShortDiffTimeAvg_Th = 100 #50 #     #recommended default: 1) "100" for "MD_HogMethod = 1"
MD_HogDist_LongDiffTimeAvg_Th = 200 #100 #    #recommended default: 1) "200" for "MD_HogMethod = 1"

HogDist_TimeAvg_Ratio_Th = 2.0 #2.5 #     #recommended default: 1) "2.0" for "MD_HogMethod = 1"
######################################################################
#R5                        LowTH   HighTh  LowNum  HighNum  Scale   Th
#daymode                    60       110     5       2        1     30
#daymode_spotlight          45       90      4       2        1     30
#nightmode                  50       100     4       2        1     30

##################################################################################################################################################################   											  
		
Cls_EnableMDOutput  = 1              #default is 1, means using MD output as classication input ROI; 0: means using whole image(MD_ScaledW*MD_ScaledH) as OC input image;		
Cls_Method          = 0		         #default is 0: close post-processor, just completed the motion detection and send out results; 1: running post-processor method after MD. 					
Cls_PersonTh        = 0.75
Cls_CarTh           = 0.7
Cls_AnimalTh        = 0.75
Cls_BgTh            = 0.5
Cls_ModelType       = 0              #0: default float; 1: int 16; 2: int8; 	
Cls_ModelInputW     = 128
Cls_ModelInputH     = 128
Cls_CropRate        = 0.875             #image pre-process, crop (1-CropRate) part from input ROI image.

EnableBatch         = 0                #1: when we run 'run.bat', please make this value as 1; avoid delete *.yuv file in 'HOGMD.exe' command
									   #0: else when we run 'HOGMD.exe' directly, please set this value as 0, because we will change the .yuv output as mp4 and delete all the *.yuv files								
											   


