# New Input File Format is as follows
# <ParameterName> = <ParameterValue> # Comment
#
# See cfg_input.h for a list of supported ParameterNames


##########################################################################################
# Input and output files
##########################################################################################
InputFileType       = 1              # 0: YUV420P video, 1: auto detect, 2: Y video, 3: YUV422P video
InputFilePath       = "../../../data/bcap20200804_170213_640x360_P420.yuv"     # 
InputWidth          = 0            # input video/image width, ignore if InputFileType is 1
InputHeight         = 0            # input video/image height, ignore if InputFileType is 1
StartFrameIdx       = 0            # start frame index. Start from 0.
FramesToBeProcessed = -1 #100      # number of frames to be processed. -1: all frames after StartFrameIdx.
OutputFilePath      = "output"     # output files path



##########################################################################################
# parameters
##########################################################################################
MD_Scale_Method          =  0        # 0: scale down using ffmpeg. (Not bit-match with HW scale !). 1. use MD HW scale(downsample actually).
MD_Scale_KeepAspectRatio = 1         # 0: not keep aspect ratio. 1: keep aspect ratio, ScaledH = (nFrmH * MD_ScaledW / nFrmW) & (~1).
MD_ScaledW              = 480         # HW:scaled width
MD_ScaledH              = 384         # HW:available when (MD_Scale_KeepAspectRatio==0).

MD_Padding_Method  = 0               # about how to get the (MD_HogBlockSize+4)*(MD_HogBlockSize+4) window for each block,
                                     # 0: load a (MD_HogBlockSize+4)*(MD_HogBlockSize+4) window from the image, do padding if it's out of image boundary.
                                     # 1: load a MD_HogBlockSize*MD_HogBlockSize window from the image, pad its surrounding 2 rows/columns with zero.
                                     # 2: HW use this method ;load a MD_HogBlockSize*MD_HogBlockSize window from the image, pad its surrounding 2 rows/columns with its boundary data.

MD_RefFrmIdx        = 1              # HW:1~7 #        # suppose current frame index is N, use the (N - MD_RefFrmIdx)th frame as reference frame.



##-------------------------------------------------------------------------------------------------------------------
## Parameters for metrics
##-------------------------------------------------------------------------------------------------------------------
MD_MetricMode       = 2              # 4 bits, [1, 15]
                                     # Specify which metrics to use for motion detection
                                     # bit 0: HOG (same as before)
                                     # bit 1: L1 moment of gradients (both block and cells)    
                                     # bit 2: Center coordinate of gradients (both block and cells)
                                     # bit 3: L1 moments of gradients for each 2x2 block, used to produce high res MD map (320x180/160x90)
                                     # NOTE: 
                                     #      - Ok to enable ANY combination of bit 0/1/2
                                     #      - When bit 3 is on, at least one of 0/1/2 must be turned on
                                     #      - For example, "= 3" would enable both HOG and L1 moment, "=7" would enable all thress metrics,
                                     #                     "= 9" would enable HOG at 320x180 or 160/90 output resolution.
                                     #      - If multiple metrics are enabled, distortion will be calculated as a sum of all enabled metrics
MD_ShiftHistMag2    = 3              # HW:3 bits, [0, 7]
                                     # shit to be applied to magniture of metric2
MD_ShiftMetric2_Th  = 6              # HW:4 bits, [0, 15]
                                     # shift value to be applied to metric=2 for adjustment. (night ==> 6, day ==> 7)


##-------------------------------------------------------------------------------------------------------------------
## Parameters for neighbor correlation
##-------------------------------------------------------------------------------------------------------------------
MD_NeighborCorrelation = 1           # HW:1 bit, [0, 1]
                                     # Looks at temporal/spatial neighbor blocks to trigger motion, def = 0
MD_ActBlk_MinMaxRatio_Scale = 16     # HW:8 bits, [0, 255]
                                     # Ratio between min and max block dist on previous frames. Used to distinguash a true and false events.
MD_ActBlkRepeatFrmCntTh = 3          # HW:4 bits, [0, 15]
                                     # minimum # of successive frame count for a block to trigger motion, def = 3
MD_ActNeighborBlkCntTh   = 2         # HW:4 bits, [0, 9]
                                     # minimum # of neighbour active blocks in a given region to trigger motion, def = 2. Note both processed spatial and temporal neighbors are included.
MD_HogDist_Th_nnAdj_Scale = 4        # HW:5 bits, [0, 31]
                                     # adjustment factor to "MD_HogDist_Th" based on neighbor availability, def = 4

##-------------------------------------------------------------------------------------------------------------------
## Parameters for handling Luminance change/AGC
##-------------------------------------------------------------------------------------------------------------------
MD_HogDist_Th_AvgYDiffAdj_Scale = 42 # HW:8bit [0, 255]
                                     # 0 - no effects, 42 - recommended: a scale factor for adjusting "MD_HogDist_Th" in the presence of global luminance change

##-------------------------------------------------------------------------------------------------------------------
## Parameters for handling rapid MD response
##-------------------------------------------------------------------------------------------------------------------
MD_LowDelayEn                = 1         # HW:1 bit [0, 1]
                                         # switch to enable low delay MD response, def = 1 
MD_HogDist_Th_lowDelay_shift = 1         # HW:2 bit [0, 3]
                                         # adjustment factor to "nMD_HogDist_Th" for allowing rapid MD response, def = 1
MD_HogDist_Th_lowDelay_nn_count = 1      # HW:4 bit [0, 15]
                                         # of nn required for allowing rapid MD response, def = 1
MD_HogDist_Th_LowDelay_prev_nn_count = 1 # HW:3 bit [0, 7]
                                         # of nn on previous frame required for allowing rapid MD response, def = 1
##-------------------------------------------------------------------------------------------------------------------
##-------------------------------------------------------------------------------------------------------------------
##-------------------------------------------------------------------------------------------------------------------



MD_HogMethod        = 1              # 1: normal HOG
MD_HogDistAvailCheck = 1             # HW: 0: no check, hog distance is available for all blocks. 1: hog distance is available when a block's difference from the reference frame is high.

#parameters useable for (MD_HogMethod==1)
MD_HogBlockSize     = 16             # block size, can't change.
MD_HogCellSize      = 16              # HW:0x00,bit[7];cell size.(support 8 and 16 two cases)
MD_HogBlockStride   = 8              # block stride.can't change.
MD_HogGradX         = "-1,-2,0,2,1"  # HW:a 5x1 template for GradX calculation. (support changed, no longer than 1*5).
MD_HogGradY         = "-1,-2,0,2,1"  # HW:a 1x5 template for GradY calculation. (support changed, no longer than 1*5).
MD_HogMagnitudeWeightEn = 1          # HW:0x00,bit[2]; 1: use weighted gradient magnitude, 0: no weighted gradient magnitude.
MD_HogSmoothBinsEn    = 1            # HW:0x00,bit[1]; 1: apply smooth filter [1/4, 2/4, 1/4] to the histogram bins before normalization. 0: no smooth filter needed.
MD_HogNormalizeMode = 0              # HW:0x00,bit[5:4]; 0: disable hog normalization, 1: enable hog normalization, output hist norm, 2:  enable hog normalization, output sum of gradient magnitude.
MD_HogDist_AvgYDiffCalc_Method = 1   # update threshold, HW uses default method '1'.   0: every block line, 1: every block, 2: every frame.
MD_HogDist_AvgYDiffThre_Scale = 8   # HW:0x18,bit[15:8]; a scale factor with 4 bits precision. AvgYDiffThre = (AvgYDiff * MD_AvgYDiffThre_Scale) >> 4. The bigger of this scale, the higher of the AvgYDiffThre, which will remove more candidate block
MD_HogDist_WeightMethod = 0          # HW:0x00,bit[3]; x2 distance with weighting method. 0: "curBlkVar + abs(curBlkVar - refBlkVar), 1: "curBlkVar + MAX(curBlkVar-refBlkVar, 0). Available when (MD_HogNormalizeMode=1/2).

#Paramerters used for all MD_HogMethod
MD_HogDist_Scale2 = 10               # HW:8 bits, [0, 255], Counterpart of "MD_HogDist_Scale" for metric=2.   Recommended: 10 --> 640x360,  15 --> 320x180  

MD_DbgEn            = 0xfffa
											# bit 0: output MDet (hog and hog distance calculation) debug information,
                                            # bit1: dump compYUV (comp_*_P420.yuv), 
											# bit2: dump block level hogDist, 
											# bit3: show motion area in input yuv (motionArea_*_P420.yuv),
											# bit4: show hogDist in yuv file (hogDist_*_P420.yuv, the third part of comp_*_P420.yuv).
											# bit5: dump cur and ref frame hog feature output by txt.
											# bit6: dump hog dist feature output by txt.
											# bit7: 0: close SAD. 1: enable SAD
											# bit8: dump effective block hogDist information. The threshold of 'Effective' is control by parmeter 'MD_HogDist_Th'
											# bit9: dump bbox output.
											# bit10: dump Accum output.
MD_PostProcMethod   = 0  #0:Fastest and stable, Single MD post-processing, it use (distMask: 76000-AccumMask, other chips-distMask)
                         #1:Fast and not stable, better than 0. Mulitple object MD post-processing, it can capture multiple motion area, and output motion region with biggest avghog
                         #2:frame correlation method. Need huge memory to calculation correlation features, and HOG feature maps, not suggested on 7600
                         #3:recursive method to calculate bbox
MD_HogDist_Th     = 30   #HW:in 8100MD, for pp method 0 and 4, suggest to set higher than 20; for other methods: suggest to set 15~30
MD_BlkCnt_Th      = 8    #in md PP V2 method0, used to filter out small motion area by block count.
MD_Bbox_PP_Enable   = 0   #update the bbox after BBox generator function, added in 8100 MD

#Paramerters used for MD_Bbox_PP_Enable=1
MD_Bbox_PP_Window = 2
MD_PP_Area_Converge_Thresh = 5
MD_PP_Aspect_Converge_Thresh = 5